// server.js
import express from 'express';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import cors from 'cors';

const app = express();
app.use(cors());
app.use(express.json());

const JWT_SECRET = process.env.JWT_SECRET || 'cambia-esto';
const ADMIN_USERS = [
  // Hash generado con: bcrypt.hash('TuPassFuerte123', 12)
  { id: 'admin-1', email: 'admin@ecsr.io', passwordHash: '$2b$12$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', role: 'admin' }
];

// Simulaciones de datos
const users = [
  { id: 'u1', username: 'mateo', status: 'ok', open_reports: 0 },
  { id: 'u2', username: 'userX', status: 'warned', open_reports: 2 }
];

const reports = [
  { id: 'r1', reporter_username: 'mateo', reported_username: 'userX', reported_id: 'u2', reason: 'acoso', status: 'open', conversation_id: 'c42' }
];

const conversations = {
  'c42': { id: 'c42', messages: [
    { ts: Date.now()-600000, from: 'mateo', text: 'hola' },
    { ts: Date.now()-590000, from: 'userX', text: 'mensaje cuestionable' }
  ], muted: false }
};

// Middleware auth
function authAdmin(req, res, next) {
  const header = req.headers.authorization || '';
  const token = header.replace(/^Bearer /, '');
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    if (payload.role !== 'admin') return res.status(403).send('Forbidden');
    req.admin = payload; next();
  } catch {
    return res.status(401).send('Unauthorized');
  }
}

// Auth
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body || {};
  const admin = ADMIN_USERS.find(a => a.email === email);
  if (!admin) return res.status(401).send('Credenciales inválidas');
  const ok = await bcrypt.compare(password, admin.passwordHash);
  if (!ok) return res.status(401).send('Credenciales inválidas');
  const token = jwt.sign({ sub: admin.id, role: 'admin', email }, JWT_SECRET, { expiresIn: '2h' });
  res.json({ token });
});

// Moderación
app.get('/api/mod/reports', authAdmin, (req, res) => res.json(reports));

app.get('/api/mod/users/:idOrName', authAdmin, (req, res) => {
  const q = req.params.idOrName.toLowerCase();
  const u = users.find(x => x.id === q || x.username.toLowerCase() === q);
  if (!u) return res.status(404).send('Usuario no encontrado');
  res.json(u); // Nota: nunca devolver hashes ni datos sensibles
});

app.post('/api/mod/ban', authAdmin, (req, res) => {
  const { userId, reason } = req.body || {};
  // Marca en DB y revoca tokens/sesiones
  console.log(`BAN -> ${userId} por ${reason}`);
  res.json({ ok: true });
});

app.get('/api/mod/conversations/:id', authAdmin, (req, res) => {
  const c = conversations[req.params.id];
  if (!c) return res.status(404).send('Conversación no encontrada');
  // Mostrar contenido solo si tus Términos lo permiten (y aplicas minimización de datos)
  res.json({ id: c.id, messages: c.messages });
});

app.post('/api/mod/conversations/:id/mute', authAdmin, (req, res) => {
  const c = conversations[req.params.id]; if (!c) return res.status(404).send('No encontrada');
  c.muted = true; res.json({ ok: true });
});

app.post('/api/mod/reports/:id/close', authAdmin, (req, res) => {
  const r = reports.find(x => x.id === req.params.id); if (!r) return res.status(404).send('No encontrado');
  r.status = 'closed'; res.json({ ok: true });
});

app.post('/api/mod/reports/by-conv/:id/close', authAdmin, (req, res) => {
  const r = reports.find(x => x.conversation_id === req.params.id); if (!r) return res.status(404).send('No encontrado');
  r.status = 'closed'; res.json({ ok: true });
});

// Restablecimiento de contraseña (seguro, sin ver contraseñas)
app.post('/api/auth/password/reset', async (req, res) => {
  const { email } = req.body || {};
  // Genera token de un solo uso y envía email con enlace seguro
  console.log(`Enviar email de reset a ${email}`);
  res.json({ ok: true });
});

app.listen(3000, () => console.log('API moderación en http://localhost:3000'));
